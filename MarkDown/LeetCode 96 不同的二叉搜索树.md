## 题目

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

**示例**:

>输入: 3
>输出: 5
>解释:
>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:
>>1         3     3      2      1
>\       /     /      / \      \
>3     2     1      1   3      2
>/     /       \                 \
>2     1         2                 3

来源：力扣（LeetCode）

链接：[https://leetcode-cn.com/problems/unique-binary-search-trees](https://leetcode-cn.com/problems/unique-binary-search-trees?fileGuid=VP3YHyDP3GwGRY6V)

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 方法

### 方法一：动态规划

给定一个有序序列 1⋯n，为了构建出一棵二叉搜索树，我们可以遍历每个数字 i，将该数字作为树根，将1⋯(i−1) 序列作为左子树，将(i+1)⋯n 序列作为右子树。接着我们可以按照同样的方式递归构建左子树和右子树。在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，我们可以想到使用动态规划来求解本题。

题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：

1. G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。
2. F(i,n): 以 i为根、序列长度为 n 的不同二叉搜索树个数 (1≤i≤n)。

可见，G(n) 是我们求解需要的函数。

G(n) 可以从F(i,n) 得到，而 F(i,n) 又会递归地依赖于 G(n)。

首先，根据上一节中的思路，不同的二叉搜索树的总数 G(n)，是对遍历所有 i (1≤i≤n) 的 F(i,n) 之和。换言之：

$$G(n) = \sum_{i=1}^{n}{F(i,n)}$$

对于边界情况，当序列长度为 1（只有根）或为 0（空树）时，只有一种情况，即：

G(0)=1,G(1)=1

给定序列1⋯n，我们选择数字 i 作为根，则根为 i 的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树，如下图所示：

![图片](https://uploader.shimo.im/f/dKO7TD22MAKqqZEA.png!thumbnail?fileGuid=VP3YHyDP3GwGRY6V)

举例而言，创建以 3 为根、长度为 7 的不同二叉搜索树，整个序列是 [1,2,3,4,5,6,7]，我们需要从左子序列[1,2] 构建左子树，从右子序列 [4,5,6,7] 构建右子树，然后将它们组合（即笛卡尔积）。对于这个例子，不同二叉搜索树的个数为F(3,7)。我们将[1,2] 构建不同左子树的数量表示为G(2), 从[4,5,6,7] 构建不同右子树的数量表示为G(4)，注意到 G(n) 和序列的内容无关，只和序列的长度有关。于是，F(3,7)=G(2)⋅G(4)。 因此，我们可以得到以下公式：

F(i,n) = G(i-1).G(n-i)

将上述两个公式结合，可以得到G(n)的递推公式：

$$G(n) = \sum_{i=1}^{n}{G(i-1).G(n-i)}$$

至此，我们从小到大计算 G 函数即可，因为 G(n) 的值依赖于G(0)⋯G(n−1)。

```java
class Solution {
    public int numTrees(int n) {
        int[] G = new int[n + 1];
        G[0] = 1; // 空树也算是一棵树
        G[1] = 1; // 单节点只能有一棵树
        for(int i = 2; i <= n; i++){ 
            // 计算以i为根节点的左右子树集合的笛卡尔积
            for(int j = 1; j <= i; j++){
                G[i] += G[j - 1] * G[i -j];
            }
        }
        return G[n];
    }
}
```
时间复杂度：O(n^2)
空间复杂度：O(n)

### 方法二：数学

方法一中的递推公式G(n)的值在数学上称为卡特兰数，卡特数的递推公式如下

$$C_{0} = 1,C_{n+1} = \frac{2(2n+1)}{n+2}C_{n}$$

```java
class Solution {
public int numTrees(int n) {
long C = 1;
for(int i =1; i < n; i++){
C = C * 2 * (2 * i + 1) / (i + 2);
}
return (int)C;
}
}
```
时间复杂度：O(n)
空间复杂度：O(1)

